// Demo: NMEA2000 library. 
// This demo reads messages from NMEA 2000 bus and
// sends them translated to clear text to Serial.

// Note! If you use this on Arduino Mega, I prefer to also connect interrupt line
// for MCP2515 and define N2k_CAN_INT_PIN to related line. E.g. MessageSender
// sends so many messages that Mega can not handle them. If you only use
// received messages internally without slow operations, then youmay survive
// without interrupt.

// auto generated by the build script
#include "version.h"

#include <Arduino.h>
#include <Wire.h>

#include "esp_log.h"
#include "freertos/FreeRTOS.h"
#include "driver/gpio.h"
#include "driver/twai.h"

uint8_t temprature_sens_read();

#define TAG "main"


// Pins   
#ifdef ESP_32_BOARD
// ESP32
#define ESP32_CAN_RX_PIN GPIO_NUM_22
#define ESP32_CAN_TX_PIN GPIO_NUM_23
#else
// ESP32-C3
#define ESP32_CAN_RX_PIN GPIO_NUM_8
#define ESP32_CAN_TX_PIN GPIO_NUM_10
#define BMS_RX_PIN GPIO_NUM_4
#define BMS_TX_PIN GPIO_NUM_2
#endif
#define MAX_NMEA2000_MESSAGE_SEASMART_SIZE 1024

//#define ONEWIRE_GPIO_PIN GPIO_NUM_21
//#define SDA_PIN GPIO_NUM_18
//#define SCL_PIN GPIO_NUM_5
//#define DISPLAY_BUTTON GPIO_NUM_34

// RS584 on Serial2 TX
//#define RS485_TX GPIO_NUM_17
//#define RS485_RX GPIO_NUM_16
//#define RS485_EN GPIO_NUM_4



// Calibrations to take account of resistor tollerances, this is specific to the board being flashed.
// should probably be in a config file eventually.



#include <NMEA2000_esp32.h>

// The method recomended doesnt work well so explicitly create the NMEA2000 objects to be sure
// the pins are correct. I've had loads of problems with this depening 
// on how the libraries are created.

tNMEA2000_esp32 &NMEA2000=*(new tNMEA2000_esp32(ESP32_CAN_TX_PIN, ESP32_CAN_RX_PIN));


// #include <NMEA2000_CAN.h>

#include "listdevices.h"
#include "N2KPrinter.h"
#include "performance.h"
#include "N2KHandler.h"
#include "N2KFrameFilter.h"
#include "NMEA0183N2KMessages.h"
#include "network.h"
#include "AsyncTcpServer.h"
#include "echoserver.h"
#include "udpsender.h"
#include "logbook.h"
#include "N2KFreezeFrame.h"
#include "Seasmart.h"
#include "AsyncDNSServer.h"
#include <ESPmDNS.h>
#include "jdb_bms.h"


#include "esp32-hal-psram.h"



// Only define this if the main loop os so slow that 
// button presses dont work properly.
// #define USE_INTERRUPT 1

Stream *OutputStream = &Serial;
N2KPrinter n2kPrinter(OutputStream);
ListDevices listDevices(&NMEA2000, OutputStream);


LogBook logbook;
N2KFreezeFrame engineFreezeFrame;
Wifi wifi(OutputStream);
// only respond to this dns. We do not want traffic to google.
// modified version of the standard esp32 DNSServer
DNSServer dnsServer("boatsystems.local,boatsystems");
WebServer webServer(OutputStream);
EchoServer echoServer;
AsyncTcpServer nmeaServer(OutputStream, 10110);
UdpSender nmeaSender(OutputStream);

NMEA0183N2KMessages messageEncoder;
Performance performance(&messageEncoder);
N2KHandler n2kHander(messageEncoder, performance, logbook);
N2KFrameFilter frameFilter;
N2KFrameFilter inputAllowFilter;


JBDBmsSimulator simulator;
JdbBMS bms;
bool bmsSimulatorOn = false;







const unsigned long TransmitMessages[] PROGMEM={
        127506L, //DCStatus(N2kMsg)
        127508L, //DCBatteryStatus(N2kMsg)
        127513L, //BatteryConfigurationStatus(N2kMsg)
0};
const unsigned long ReceiveMessages[] PROGMEM={/*126992L,*/ // System time
        126992L, //SystemTime(N2kMsg)
        127245L, //Rudder(N2kMsg)
        127250L, //Heading(N2kMsg)
        127257L, //Attitude(N2kMsg)
        127488L, //EngineRapid(N2kMsg)
        127489L, //EngineDynamicParameters(N2kMsg)
        127493L, //TransmissionParameters(N2kMsg)
        127497L, //TripFuelConsumption(N2kMsg)
        127501L, //BinaryStatus(N2kMsg)
        127505L, //FluidLevel(N2kMsg)
        127506L, //DCStatus(N2kMsg)
        127508L, //DCBatteryStatus(N2kMsg)
        127513L, //BatteryConfigurationStatus(N2kMsg)
        128259L, //Speed(N2kMsg)
        128267L, //WaterDepth(N2kMsg)
        129026L, //COGSOG(N2kMsg)
        129029L, //GNSS(N2kMsg)
        129033L, //LocalOffset(N2kMsg)
        129045L, //UserDatumSettings(N2kMsg)
        129540L, //GNSSSatsInView(N2kMsg)
        130310L, //OutsideEnvironmental(N2kMsg)
        130311L, //EnvironmentalParameters(N2kMsg)
        130312L, //Temperature(N2kMsg)
        130313L, //Humidity(N2kMsg)
        130314L, //Pressure(N2kMsg)
        130316L, //TemperatureExt(N2kMsg)
        129283L, //Xte(N2kMsg)
        127258L, //MagneticVariation(N2kMsg)
        130306L, //WindSpeed(N2kMsg)
        128275L, //Log(N2kMsg)
        129025L, //LatLon(N2kMsg)
        128000L, //Leeway(N2kMsg)
        0};






#ifdef ENABLE_WEBSOCKETS
// The ESPAsyncWebServer websocket implementation tends to corrupt the heap
// so not using any more.
void sendViaWebSockets(const tN2kMsg &N2kMsg) {
    static char wsBuffer[MAX_NMEA2000_MESSAGE_SEASMART_SIZE];
    static unsigned long flushTTL = millis();
    static size_t wsOffset = 0;



    // flush the ws buffer if required.
    unsigned long now = millis();
    if ( (now - flushTTL) > 200) {
      flushTTL = now;
      if ( wsOffset > 0) {
        webServer.sendN2K((const char *)&wsBuffer[0]); 
        wsOffset = 0;               
      }
    }

    // check if any websocket client has requested this PGN
    if ( !frameFilter.isFiltered(N2kMsg.PGN, N2kMsg.Source ) && webServer.shouldSend(N2kMsg.PGN) ) {
      // todo, use real time based on GPS time.
      // buffer the messages up to reduce websocket overhead.
      size_t maxLen = MAX_NMEA2000_MESSAGE_SEASMART_SIZE-wsOffset-1;
      if ( maxLen < 50) {
        // reset the buffer
        webServer.sendN2K((const char *)&wsBuffer[0]); 
        flushTTL = now;
        wsOffset = 0;       
      } else if ( wsOffset > 0) {
        // replace the terminator with a \n
        // and to be safe add a terminator
        wsBuffer[wsOffset++] = '\n';
        wsBuffer[wsOffset] = 0;
      }
      size_t len = N2kToSeasmart(N2kMsg,millis(),&wsBuffer[wsOffset],maxLen);
      wsOffset += len;
    }
}
#else
void sendViaWebSockets(const tN2kMsg &N2kMsg) {
}
#endif


uint16_t HandleSeasmartMsg(const char *msg) {
  tN2kMsg N2kMsg;
  uint32_t ts;
  if(SeasmartToN2k(msg, ts, N2kMsg)) {
    // only allow listed messages are allowed
    // NB this is an allow filter, not a drop filter.
    if ( inputAllowFilter.isPgnFiltered(N2kMsg.PGN) ) {
      // The source is set to this device in send.
      NMEA2000.SendMsg(N2kMsg);
      return 200;      
    }
    return 403;
  }
  return 400;
}



void HandleNMEA2000Msg(const tN2kMsg &N2kMsg) {
    static char seaSmartBuffer[MAX_NMEA2000_MESSAGE_SEASMART_SIZE];
    listDevices.HandleMsg(N2kMsg);
    n2kPrinter.HandleMsg(N2kMsg);
    n2kHander.handle(N2kMsg);
    engineFreezeFrame.handle(N2kMsg);

    bool seaSmartLoaded = false;
#ifdef NMEA0183_TCP
    if ( nmeaServer.acceptN2k(N2kMsg.PGN) ) {
      N2kToSeasmart(N2kMsg,millis(),&seaSmartBuffer[0],MAX_NMEA2000_MESSAGE_SEASMART_SIZE);
      seaSmartLoaded = true;
      nmeaServer.sendN2k(N2kMsg.PGN, (const char *) &seaSmartBuffer[0]);
    }
#endif
    if ( webServer.acceptSeaSmart(N2kMsg.PGN) ) {
      if ( !seaSmartLoaded ) {
        N2kToSeasmart(N2kMsg,millis(),&seaSmartBuffer[0],MAX_NMEA2000_MESSAGE_SEASMART_SIZE);
      }
      webServer.sendSeaSmart(N2kMsg.PGN, (const char *) &seaSmartBuffer[0]);
    }

    sendViaWebSockets(N2kMsg);
}

void showHelp() {
  OutputStream->println("N2KWifi Bridge.");
  OutputStream->print("Git Version: ");OutputStream->println(GIT_SHA1_VERSION);
  OutputStream->println("  - Send 'h' to show this message");
  OutputStream->println("  - Send 's' to show status");
  OutputStream->println("  - Send 'u' to print latest list of devices");
  OutputStream->println("  - Send 'o' to toggle output, can be high volume");
  OutputStream->println("  - Send 'd' to toggle packet dump, can be high volume");
  OutputStream->println("  - Send 'b' to toggle bms debug, can be high volume");
  OutputStream->println("  - Send 'f' to trigger freeze frame");
  OutputStream->println("  - Send 'S' to toggle BMS simulator");
  OutputStream->println("  - Send 'p' set udp port");
  OutputStream->println("  - Send 'A' to toggle Wifi AP");
  OutputStream->println("  - Send 'R' to restart");
}


// This must not block as it is called while parsing messages.

void SendNMEA0183Message(const char * buf) {
  nmeaServer.sendBufToClients(buf); // TCP
  nmeaSender.sendBufToClients(buf); // UDP
#ifdef NMEA0183_WEBSOC
  webServer.sendN0183(buf); // websocket
#endif
}





TaskHandle_t alert_monitor_task_handle_;


uint16_t twai_alert_above_err_warn = 0;
uint16_t twai_alert_below_err_warn = 0;
uint16_t twai_alert_err_active = 0;
uint16_t twai_alert_recovery_in_progress = 0;
uint16_t twai_alert_bus_recovered = 0;
uint16_t twai_alert_arb_lost = 0;
uint16_t twai_alert_bus_error = 0;
uint16_t twai_alert_tx_failed = 0;
uint16_t twai_alert_rx_queue_full = 0;
uint16_t twai_alert_err_pass = 0;
uint16_t twai_alert_bus_off = 0;

void twaiAlertStatus(Print *stream) {
  stream->print("twai_alert_above_err_warn:");stream->println(twai_alert_above_err_warn);
  stream->print("twai_alert_below_err_warn:");stream->println(twai_alert_below_err_warn);
  stream->print("twai_alert_err_active:");stream->println(twai_alert_err_active);
  stream->print("twai_alert_recovery_in_progress:");stream->println(twai_alert_recovery_in_progress);
  stream->print("twai_alert_bus_recovered:");stream->println(twai_alert_bus_recovered);
  stream->print("twai_alert_arb_lost:");stream->println(twai_alert_arb_lost);
  stream->print("twai_alert_bus_error:");stream->println(twai_alert_bus_error);
  stream->print("twai_alert_tx_failed:");stream->println(twai_alert_tx_failed);
  stream->print("twai_alert_rx_queue_full:");stream->println(twai_alert_rx_queue_full);
  stream->print("twai_alert_err_pass:");stream->println(twai_alert_err_pass);
  stream->print("twai_alert_bus_off:");stream->println(twai_alert_bus_off);


  twai_status_info_t status_info;
  if (twai_get_status_info(&status_info) == ESP_OK) {
    stream->print("TWAI state:");
    switch(status_info.state) {
      case TWAI_STATE_STOPPED: stream->print("stopped ");break;
      case TWAI_STATE_RUNNING: stream->print("running ");break;
      case TWAI_STATE_BUS_OFF: stream->print("off ");break;
      case TWAI_STATE_RECOVERING: stream->print("recovering ");break;
      default: stream->print("unknown ");break;
    }
    stream->print(" tx(queued:");stream->print(status_info.msgs_to_tx);
    stream->print(" errors:");stream->print(status_info.tx_error_counter);
    stream->print(" failed:");stream->print(status_info.tx_failed_count);
    stream->print(" ) rx (waiting:");stream->print(status_info.msgs_to_rx);
    stream->print(" rx errors:");stream->print(status_info.rx_error_counter);
    stream->print(" rx missed:");stream->print(status_info.rx_missed_count);
    stream->print(" ) arb lost:");stream->print(status_info.arb_lost_count);
    stream->print(" bus errors:");stream->print(status_info.bus_error_count);
    stream->println("");
  } else {
    stream->println("twai no status");
  }

}


void monitorAlertsTask(void *pvParameters) {
    uint32_t alerts_to_enable = TWAI_ALERT_ALL;
    if (twai_reconfigure_alerts(alerts_to_enable, NULL) == ESP_OK) {
        ESP_LOGE(TAG,"Alerts reconfigured\n");
    } else {
        ESP_LOGE(TAG, "Failed to reconfigure alerts");
    }

    while(1) {
        uint32_t alerts;
        twai_read_alerts(&alerts, portMAX_DELAY);
        if (alerts & TWAI_ALERT_ABOVE_ERR_WARN) {
            ESP_LOGE(TAG, "Surpassed Error Warning Limit");
            twai_alert_above_err_warn++;
        }
        if (alerts & TWAI_ALERT_BELOW_ERR_WARN) {
            ESP_LOGE(TAG, "Error counters dropped below warning level.");
            twai_alert_below_err_warn++;
        }
        if (alerts & TWAI_ALERT_ERR_ACTIVE) {
            ESP_LOGE(TAG, "TWAI Controller active");
            twai_alert_err_active++;
        }
        if (alerts & TWAI_ALERT_RECOVERY_IN_PROGRESS) {
            ESP_LOGE(TAG, "TWAI Controller bus recovery");
            twai_alert_recovery_in_progress++;
        }
        if (alerts & TWAI_ALERT_BUS_RECOVERED) {
            ESP_LOGE(TAG, "TWAI Controller bus recovered");
            twai_alert_bus_recovered++;
        }
        if (alerts & TWAI_ALERT_ARB_LOST) {
            ESP_LOGI(TAG, "TWAI Arbritration lost");
            twai_alert_arb_lost++;
        }
        if (alerts & TWAI_ALERT_BUS_ERROR) {
            ESP_LOGE(TAG, "Bus error");
            twai_alert_bus_error++;
        }
        if (alerts & TWAI_ALERT_TX_FAILED) {
            ESP_LOGE(TAG, "Tx failed");
            twai_alert_tx_failed++;
        }
        if (alerts & TWAI_ALERT_RX_QUEUE_FULL) {
            ESP_LOGE(TAG, "Rx Queue Full %d", twai_alert_rx_queue_full);
            twai_alert_rx_queue_full++;
        }
        if (alerts & TWAI_ALERT_ERR_PASS) {
            ESP_LOGE(TAG, "TWAI now error passive");
            twai_alert_err_pass++;
        }
        if (alerts & TWAI_ALERT_BUS_OFF) {
            ESP_LOGE(TAG, "TWAI bus off state");
            twai_alert_bus_off++;
        }
        vTaskDelay(pdMS_TO_TICKS(1000)); // pause 1s

    }
    ESP_LOGE(TAG, "TWAI Alert monitor task exited");
    vTaskDelete(NULL);
}

void printStatus(Print *stream) {
  stream->print("Total heap:  ");stream->println(ESP.getHeapSize());
  stream->print("Free heap:   ");stream->println(ESP.getFreeHeap());
  // ESP32-WROOM chips which are common dont have PSRAM. 
  // ESP32-WRover do. See https://en.wikipedia.org/wiki/ESP32
  stream->print("Has PSRAM:");stream->println(psramFound());
  stream->print("Total PSRAM: ");stream->println(ESP.getPsramSize());
  stream->print("Free PSRAM:  ");stream->println(ESP.getFreePsram());


  twaiAlertStatus(stream);
  wifi.printStatus(stream);

  nmeaServer.printStatus(stream);
  webServer.printStatus(stream);
  bms.printStatus(stream);
}


void setup() {
  Serial.begin(115200); 
  if ( !psramInit() ) {

    ESP_LOGE(TAG, "PSRAM not available.");
  } else {
    ESP_LOGI(TAG, "Total PSRAM: %d", ESP.getPsramSize());
    ESP_LOGI(TAG, "Free PSRAM:  %d", ESP.getFreePsram());
  }
  ESP_LOGI(TAG, "Starting Wifi");
  // Start the wifi
  wifi.begin();



  // start MDNS  so others can register.
  ESP_LOGI(TAG, "Starting MDNS");
  MDNS.begin("boatsystems");

  ESP_LOGE(TAG, "Starting TCP Servers");
  echoServer.begin();
  nmeaServer.begin();
  nmeaSender.begin();

  ESP_LOGI(TAG, "Starting Http Server");
  webServer.setStoreCallback([](Print *stream) {
    n2kHander.output(stream); // H,...
    performance.output(stream); // P,...
  });

  webServer.setStatusCallback([](Print *stream) {
    printStatus(stream);
  });

  webServer.setDeviceListCallback([](Print *stream) {
    listDevices.output(stream);
  });

  webServer.setSeasmartCallback(HandleSeasmartMsg);

  webServer.begin();

  frameFilter.begin("n2k.filter");
  inputAllowFilter.begin("n2k.apifilter");





  ESP_LOGI(TAG, "Starting BMS Stack");
  #ifdef ESP_32_BOARD
  Serial1.begin(9600,SERIAL_8N1);
  #else
  Serial1.begin(9600,SERIAL_8N1, BMS_RX_PIN, BMS_TX_PIN);
  #endif
  bms.setSerial(&Serial1);
  bms.begin();



  if (dnsServer.start()) {
    Serial.println("Started DNS server");
  } else {
    Serial.println("DNS Server not started, not in AP mode");
  }


  ESP_LOGI(TAG, "Starting Nmea20000 Stack");
  // Set Product information
  NMEA2000.SetProductInformation("00000003", // Manufacturer's Model SerialIO code
                                 100, // Manufacturer's product code
                                 "N2k Wifi bridge",  // Manufacturer's Model ID
                                 "1.0.0.10 (2017-07-29)",  // Manufacturer's Software version code
                                 "1.0.0.0 (2017-07-12)" // Manufacturer's Model version
                                );

  // Set device information
  NMEA2000.SetDeviceInformation(5, // Unique number. Use e.g. SerialIO number.
                                130, // Device function=Display. See codes on http://www.nmea.org/Assets/20120726%20nmea%202000%20class%20&%20function%20codes%20v%202.00.pdf
                                120, // Device class=Display. See codes on  http://www.nmea.org/Assets/20120726%20nmea%202000%20class%20&%20function%20codes%20v%202.00.pdf
                                2046 // Just choosen free from code list on http://www.nmea.org/Assets/20121020%20nmea%202000%20registration%20list.pdf
                               );


  messageEncoder.setSendBufferCallback(SendNMEA0183Message);

//  NMEA2000.SetN2kCANReceiveFrameBufSize(50);
  // Do not forward bus messages at all
  NMEA2000.SetForwardType(tNMEA2000::fwdt_Text);
  NMEA2000.SetForwardStream(OutputStream);
  // Set false below, if you do not want to see messages parsed to HEX withing library
  NMEA2000.EnableForward(false);
  // set the TWAI RX buffer sizes larger to cope with overflows, TX=40 is the default
  NMEA2000.SetCANBufferSize(100,40);
  NMEA2000.SetN2kCANReceiveFrameBufSize(150);
  NMEA2000.SetN2kCANMsgBufSize(8);
  NMEA2000.ExtendTransmitMessages(TransmitMessages);
  NMEA2000.ExtendReceiveMessages(ReceiveMessages);

  NMEA2000.SetMsgHandler(HandleNMEA2000Msg);

  NMEA2000.SetMode(tNMEA2000::N2km_ListenAndNode, 50);
//  NMEA2000.SetMode(tNMEA2000::N2km_ListenOnly, 50);

  
  NMEA2000.Open();
  xTaskCreate(monitorAlertsTask, "TWAI_alertMonitor", 4096, NULL, 5, &alert_monitor_task_handle_);




  ESP_LOGI(TAG, "Running.....");
  showHelp();

  
}



//*****************************************************************************


//*****************************************************************************
//NMEA 2000 message handler - should  be in a class so it can be attached.

//=================================================
// Diagnosis Functions and control

//*****************************************************************************

//*****************************************************************************
void CheckCommand() {
  static bool enableForward = false;
  if (OutputStream->available()) {
    char chr = OutputStream->read();
    switch ( chr ) {
      case 'h': showHelp(); break;
      case 'u': listDevices.list(true); break;
      case 's':
        printStatus(OutputStream);
        break;
      case 'o': 
        n2kPrinter.showData = !n2kPrinter.showData;
        if (  n2kPrinter.showData ) {
          ESP_LOGI(TAG, "Data Output Enabled");   
        } else {
          ESP_LOGI(TAG, "Data Output Disabled");   
        }
        break;
      case 'R':
        esp_restart();
        break;
      case 'b':
        bms.toggleDebug();
        break; 
      case 'd': 
        enableForward = !enableForward;
        if (  enableForward ) {
          ESP_LOGI(TAG, "NMEA2000 Packet Output Enabled");   
        } else {
          ESP_LOGI(TAG, "NMEA2000 Packet Output Disabled");   
        }
        NMEA2000.EnableForward(enableForward); 
        break;
      case 'S':
        if ( bmsSimulatorOn) {
          ESP_LOGI(TAG, "Disable BMS Simulator");   
          bmsSimulatorOn = false;
          bms.setSerial(&Serial1);
        } else {
          ESP_LOGI(TAG, "Enable BMS Simulator");   
          bmsSimulatorOn = true;
          bms.setSerial(&simulator);
        }
        break;
      case 'p':
        {
          Serial.print("Enter UDP Port >");
          Serial.setTimeout(10000);
          String port = Serial.readStringUntil('\n');
          Serial.setTimeout(0);
          if ( port != NULL ) {
            int portNumber = port.toInt();
            if ( portNumber > 0  ) {
              Serial.printf("\nSetting port to %d\n", portNumber);
              nmeaSender.setPort(portNumber);
            } else {
              Serial.printf("\nInvalid port %s\n", port);
            }
          }           
        }
        break;
      case 'A':
        if ( wifi.isSoftAP() ) {
          dnsServer.stop();
          wifi.startSTA();
        } else {
          wifi.startAP();
          if (dnsServer.start()) {
              Serial.println("Started DNS server");
          } else {
              Serial.println("DNS Server not started, not in AP mode");
          }
        }
        break;
      case 'f':
        engineFreezeFrame.logFreezeFrame();
        break;
    }
  }
}

/**
 * Emit messages from sensors connected to the ESP. 
 * Don't send proprietary messages to the bus.
 */ 
void EmitMessages() {
    tN2kMsg N2kMsg;
    if ( bms.setN2KMsg(N2kMsg) )  {
        HandleNMEA2000Msg(N2kMsg);
    }
    if (!NMEA2000.IsProprietaryMessage(N2kMsg.PGN) ) {
      NMEA2000.SendMsg(N2kMsg);
    }
}





unsigned long start = 0;
const char *timerMessages[5] = {
"NMEA2000.ParseMessages",
"logbook.log",
"CheckCommand",
"EchoServer",
"NmeaServerCheck"
};
int16_t totalCalls = 0;
unsigned long lastPrint = 0;
unsigned long counters[5] = {0,0,0,0,0};
uint16_t calls[5] = {0,0,0,0,0};
void startTimer() {
  start = millis();
}
void endTimer(int i) {
  unsigned long end = millis();
  calls[i]++;
  totalCalls++;
  counters[i] = counters[i]+(end-start);
  if ( end-lastPrint > (+10000) ) {
    lastPrint = end;
    Serial.print(end);
    Serial.print(" times:");
    for(int j = 0; j < 5; j++ ) {
      Serial.print(",");
      if (calls[j] == 0) {
        Serial.print("-");
      } else {
        Serial.print((float)(counters[j]/calls[j]));
      }
      counters[j] = 0;
      calls[j] = 0;
    }
    Serial.print(",");
    Serial.println(totalCalls);
    totalCalls = 0;
  } 
}

//*****************************************************************************
void loop() { 
  unsigned long last = millis();
  NMEA2000.ParseMessages();
  unsigned long now = millis();
  if ( now - last > 100) {
    ESP_LOGE(TAG, "ParseMessages %ld %ld %d" ,now, last, (now - last));
  }
  last = now;
  CheckCommand();
  now = millis();
  if ( now - last > 100) {
    ESP_LOGE(TAG, "CheckCommand %ld %ld %d" ,now, last, (now - last));
  }
  last = now;
  bms.update();
  now = millis();
  if ( now - last > 100) {
    ESP_LOGE(TAG, "bms.update %ld %ld %d" ,now, last, (now - last));
  }
  last = now;
  EmitMessages();
  now = millis();
  if ( now - last > 100) {
    ESP_LOGE(TAG, "EmitMessages %ld %ld %d" ,now, last, (now - last));
  }

}
